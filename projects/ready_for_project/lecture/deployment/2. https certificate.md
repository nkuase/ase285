---
marp: true
html: true
size: 4:3
paginate: true
style: |
  h2 {
    /* text-shadow: 1px 1px 0px #000000;*/
    color: #333;
    background-color: #e1bee7;  /* Yellow background to highlight */
    padding: 0.2em 0.4em;       /* Optional padding for better appearance */
    border-radius: 0.2em;       /* Optional rounded corners */
  }
  h3 {
    text-shadow: 1px 1px 0px #000000;
    color: #333;
  }  
  strong {
    text-shadow: 1px 1px 0px #000000;
  }
  @media print {
    strong {
      text-shadow: none !important;
      -webkit-text-stroke: 0.6px rgba(0,0,0,0.35);
      text-stroke: 0.6px rgba(0,0,0,0.35); /* ignored by many, harmless */
    }
  }
  img[alt~="center"] {
    display: block;
    margin: 0 auto;
  }
    img[alt~="outline"] {
    border: 2px solid #388bee;
  }
  .columns {
    display: flex;
    gap: 2rem;
  }
  .column {
    flex: 1;
  }
---

<!-- _class: lead -->
<!-- _class: frontpage -->
<!-- _paginate: skip -->

# HTTPS Certificate

Using Let's Encrypt/mkcert

---

## What's the meaning of Certificate in HTTPS

In HTTPS, a certificate is like an official ID card for your website.

It proves two key things:

1. Identity â€” Confirms that the website really belongs to the domain owner (e.g., example.com), not an imposter.
2. Encryption â€” Contains the public key used to securely exchange data with visitors via SSL/TLS.

---

## CA - Let's Encrypt

The certificate is issued by a Certificate Authority (CA) â€” a trusted organization that verifies domain ownership: In this example, we use Letâ€™s Encrypt.

- It uses the **ACME** (Automatic Certificate Management Environment) protocol.
- The web server proves ownership through an HTTP or DNS challenge.
- Once verified, Letâ€™s Encrypt issues a trusted certificate.
- **Certbot** automates the process of requesting, installing, and renewing certificates.

---

### 1. Goal: Prove Domain Ownership

Before issuing an HTTPS certificate, Letâ€™s Encrypt must confirm that you control the domain (e.g., `example.com`).

### 2. The Challengeâ€“Response Model

Letâ€™s Encrypt uses an automated protocol called **ACME** (Automatic Certificate Management Environment).

---

#### ACME protocol overview:

1. **Request**: Your server (Certbot) asks Letâ€™s Encrypt for a certificate.  
2. **Challenge**: Letâ€™s Encrypt replies:  
   > "If you own example.com, place this secret token at a specific location."  
3. **Response**: Your server places that token (file, DNS record, etc.)  
4. **Verify**: Letâ€™s Encrypt visits your domain (HTTP or DNS) to check it exists.  
5. **Issue**: If valid, the CA issues a signed certificate.

---

### 3. Types of Validation

| Type            | Method                                       | Example              |
|-----------------|----------------------------------------------|----------------------|
| **HTTP-01**     | Put token under `.well-known/acme-challenge` | For web servers      |
| **DNS-01**      | Add TXT record to DNS                        | For wildcard domains |
| **TLS-ALPN-01** | Use TLS handshake                            | For advanced setups  |

---

### 4. What the Certificate Contains

When verified, the CA issues a **digital certificate** that includes:

- Your domain name (CN = example.com)
- Public key (you generated a private/public key pair)
- Issuer info (Letâ€™s Encrypt)
- Validity period (90 days)
- CA signature (proves authenticity)

---

### 5. The HTTPS Trust Chain

```text
Browser
  â†“ trusts
Root CA (ISRG Root X1)
  â†“ signs
Intermediate CA (R3)
  â†“ signs
Your Domain Certificate
```

- ISRG (Internet Security Research Group) is the organization behind Letâ€™s Encrypt.
- Letâ€™s Encrypt issues certificates through its intermediate CA (R3), which is signed by the root CA (ISRG Root X1) trusted by browsers.

---

## Install and run Certbot (Ubuntu)

> To install and run Certbot, you should own your domain name and VPS.
> In most cases, the web server is run on Linux, so I use Ubuntu Linux as an example.

### 1. Install Certbot

```bash
sudo apt update
sudo apt install certbot python3-certbot-nginx
```

---

### 2. Run Certboot

```bash
# Get certificate (requires public domain)
sudo certbot --nginx -d example.com -d www.example.com
```

Then certbot does the following (details in the next section):

1. Domain Verification (ACME Challenge)
2. Certificate Issuance
3. Nginx Configuration (optional, only with --nginx)

---

### 3. Renewal and Automation

- Letâ€™s Encrypt certificates are valid for 90 days to reduce security risks.
- Certbot automatically handles renewals by repeating the same ACME verification process.
- Use the command above to test that automatic renewal works correctly before relying on it in production.

```bash
sudo certbot renew --dry-run
```

---

## Detailed Certboot Actions

### Domain Verification (ACME Challenge)

1. Certbot contacts Let's Encrypt:

> "I want a certificate for example.com"

2. Let's Encrypt replies:

> "Prove you control example.com"

---

3. Certbot creates challenge file:

- Certbot parses your existing Nginx configuration â€” it looks for the server_name that matches the domain (example.com) and reads its root or location directives.
- From this, Certbot learns that requests to `http://example.com/` are served from `/var/www/html` (for example).

```txt
/var/www/html/.well-known/acme-challenge/<token>
```

4. Let's Encrypt visits:

```txt
http://example.com/.well-known/acme-challenge/<token>
```

---

### Certificate Issuance

- Let's Encrypt **signs** your public key.
- Certbot downloads:

<style scoped>
table {
  font-size: 18pt !important;
}
table thead tr {
  background-color: #aad8e6;
}
</style>

| File | Purpose |
|------|----------|
| `/etc/letsencrypt/live/example.com/fullchain.pem` | Signed certificate |
| `/etc/letsencrypt/live/example.com/privkey.pem` | Private key |

---

### Nginx Configuration (optional, only with --nginx)


1. Certbot scans your `/etc/nginx/sites-enabled/` (or `/etc/nginx/conf.d/`) for server_name entries that match the domain(s) you specify.
2. It inserts SSL directives into the matching server block, such as:

```txt
ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
include /etc/letsencrypt/options-ssl-nginx.conf;
```

---

3. It also adds a redirect from HTTP â†’ HTTPS by editing or creating a separate block:

```txt
server {
    listen 80;
    server_name example.com www.example.com;
    return 301 https://$host$request_uri;
}
```

4. Then Certbot reloads Nginx automatically so the new certificate takes effect.

---

## Local HTTPS using mkcert

Browsers warn on self-signed certs.

- Use **mkcert** to create locally trusted certs for development.
- mkcert adds a local root CA to your OS trust store, then issues certs for `localhost`, custom dev domains, etc.
- For dev only â€” never use mkcert certs in production.

---

### What mkcert is (and isnâ€™t)

- mkcert creates locally-trusted certificates by installing a local CA on *your* machine.
- Perfect for development (no browser warnings).
- Not for production => Use **Letâ€™s Encrypt** in production.

Key point:

- Browsers trust your mkcert certs **only on machines where the mkcert CA is installed**.

---

### Quick Start (mkcert)

Install mkcert and the local CA (one-time)

```bash
# Mac
brew install mkcert nss        # macOS (add nss for Firefox)

# For Ubuntu (update for your CPU)

sudo apt install libnss3-tools -y
curl -JLO "<https://dl.filippo.io/mkcert/latest?for=linux/amd64>"
```

```bash
> mkcert -install
> mkcert localhost 127.0.0.1 ::1 myapp.local

Created a new certificate valid for the following names ðŸ“œ
 - "localhost"
 - "127.0.0.1"
 - "::1"
 - "myapp.local"

The certificate is at "./localhost+3.pem" and the key at "./localhost+3-key.pem" âœ…

It will expire on 10 February 2028 ðŸ—“
```

---

### Usage of mkcert

#### Use with Node.js (Express)

```js
import fs from 'fs';
import https from 'https';
import express from 'express';

const app = express();
app.get('/', (_req, res) => res.send('Hello HTTPS (local)'));

https.createServer({
  key:  fs.readFileSync('./certs/localhost+3-key.pem'),
  cert: fs.readFileSync('./certs/localhost+3.pem'),
}, app).listen(8443, () => {
  console.log('âœ… HTTPS server running at https://localhost:8443');
});
```

---

#### Example Directory Structure

You can put them in the `certs` directory.

```txt
dev-https/
â”œâ”€ certs/
â”‚  â”œâ”€ localhost+3.pem
â”‚  â””â”€ localhost+3-key.pem
â””â”€ index.js
```

Copy this app inside dev-https/, you can start it directly from that folder (e.g., node index.js).

---

#### Use with Nginx (only for development purposes)

```bash
> mkcert -install
Created a new local CA ðŸ’¥
Sudo password:
The local CA is now installed in the system trust store!
```

- Make sure mkcert is installed on your local computer.
- You can't reuse the certificate generated for other computers.

---

1. Create a subdirectory `certs` in the Nginx configuration directory.
2. Copy the `nginx_nodejs_secure.conf` file in the `servers` or `sites-enabled` directory.

It has the same `upstream` block.

```nginx
upstream nodejs_app {
    server localhost:3000;
    keepalive 8;
}
```

---

It redirects the port 8080 to 8443.

```ngix
# HTTP Server - Redirect to HTTPS
server {
    listen 8080;
    server_name localhost;
    
    # Redirect all HTTP to HTTPS
    return 301 https://$server_name:8443$request_uri;
}
```

---

It listens to 8443 port (HTTPS).

- Be sure to change the location of the certificates.

```ngix
# HTTPS Server
server {
    listen 8443 ssl;
    server_name localhost;

    # SSL Certificate and Key
    ssl_certificate /opt/homebrew/etc/nginx/certs/localhost+3.pem;
    ssl_certificate_key /opt/homebrew/etc/nginx/certs/localhost+3-key.pem;
    ...
}    
```
